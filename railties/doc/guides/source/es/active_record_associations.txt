=== Asociaciones en Active Record
Esta guía cubre las características de las asociación en Active Record.

Después de leer esta guía, sabrá:

* Cómo declarar asociaciones entre modelos Active Record.
* Cómo entender los diversos tipos de asociaciones Active Record.
* Cómo utilizar los métodos agregados a sus modelos creando asociaciones.

==1 ¿Por qué asociaciones?
En Rails, una asociación es una conexión entre dos modelos Active Record. ¿Por qué necesitamos las asociaciones entre modelos? Porque hacen las operaciones comunes más simples y más fáciles en su código. Por ejemplo, considere una sencilla aplicación de Rails que incluye un modelo para autores y un modelo para libros. Cada autor puede tener muchos libros. Sin asociaciones, las declaraciones del modelo se verían así:

[source, ruby]
-------------------------------------------------------
class Author < ApplicationRecord
end

class Book < ApplicationRecord
end
-------------------------------------------------------

Ahora, supongamos que queremos agregar un nuevo libro para un autor existente. Necesitamos hacer algo como esto:

[source, ruby]
-------------------------------------------------------
@book = Book.create(published_at: Time.now, author_id: @author.id)
-------------------------------------------------------

O considere eliminar un autor y asegurarse de que todos sus libros también se eliminen:

[source, ruby]
-------------------------------------------------------
@books = Book.where(author_id: @author.id)
@books.each do |book|
  book.destroy
end
@author.destroy"
-------------------------------------------------------

Con las asociaciones Active Record, podemos agilizar estas y otras operaciones declarando a Rails que hay una conexión entre los dos modelos. Aquí está el código revisado para la creación de autores y libros:

[source, ruby]
-------------------------------------------------------
class Author < ApplicationRecord
  has_many :books, dependent: :destroy
end

class Book < ApplicationRecord
  belongs_to :author
end
-------------------------------------------------------

Con este cambio, crear un nuevo libro para un autor en particular es más fácil:

[source, ruby]
-------------------------------------------------------
@book = @author.books.create(published_at: Time.now)
-------------------------------------------------------

Eliminar un autor y todos sus libros es mucho más fácil:

[source, ruby]
-------------------------------------------------------
@author.destroy
-------------------------------------------------------

Para obtener más información sobre los diferentes tipos de asociaciones, lea la siguiente sección de esta guía. A continuación, algunos consejos y trucos para trabajar con asociaciones y, a continuación, una referencia completa a los métodos y opciones para las asociaciones en Rails.

==2 Tipos de Asociaciones
Rails soporta seis tipos de asociaciones:

belongs_to
has_one
has_many
has_many :through
has_one :through
has_and_belongs_to_many

Las asociaciones se implementan mediante llamadas de macro-estilo, de modo que puede añadir declarativamente características a sus modelos. Por ejemplo, al declarar que un modelo pertenece a otro, instruye a Rails para que mantenga la información de la Primary Key-Foreign Key entre instancias de los dos modelos, y también obtiene una serie de métodos de utilidad agregados a su modelo.

En el resto de esta guía, aprenderá a declarar y utilizar las diversas formas de asociaciones. Pero primero, una introducción rápida a las situaciones donde cada tipo de asociación es apropiado."

=2.1 La asociación belongs_to
Una asociación belongs_to establece una conexión uno a uno con otro modelo, de modo que cada instancia del modelo declarante ""pertenece a"" una instancia del otro modelo. Por ejemplo, si su aplicación incluye autores y libros, y cada libro se puede asignar a exactamente un autor, declararía el modelo de libro de esta manera:

class Book < ApplicationRecord
  belongs_to :author
end

Las asociaciones belongs_to deben utilizar el término singular. Si usa el formulario pluralizado en el ejemplo anterior para la asociación de autores en el modelo de Book, se le diría que hay una constante no inicializada ""uninitialized constant Book::Authors"". Esto se debe a que Rails infiere automáticamente el nombre de la clase del nombre de la asociación. Si el nombre de la asociación se pluraliza erróneamente, entonces la clase inferida también se pluralizará erróneamente.

La migración correspondiente podría tener este aspecto:

[source, ruby]
-------------------------------------------------------
class CreateBooks < ActiveRecord::Migration[5.0]
  def change
    create_table :authors do |t|
      t.string :name
      t.timestamps
    end

    create_table :books do |t|
      t.belongs_to :author, index: true
      t.datetime :published_at
      t.timestamps
    end
  end
end
-------------------------------------------------------

=2.2 La asociación has_one
Una asociación has_one también establece una conexión uno a uno con otro modelo, pero con una semántica algo diferente (y consecuencias diferentes). Esta asociación indica que cada instancia de un modelo contiene o posee una instancia de otro modelo. Por ejemplo, si cada proveedor de su aplicación tiene una sola cuenta, declararía el modelo de proveedor de la siguiente manera:

class Supplier < ApplicationRecord
  has_one :account
end

La migración correspondiente podría tener este aspecto:

[source, ruby]
-------------------------------------------------------
class CreateSuppliers < ActiveRecord::Migration[5.0]
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps
    end

    create_table :accounts do |t|
      t.belongs_to :supplier, index: true
      t.string :account_number
      t.timestamps
    end
  end
end
-------------------------------------------------------

Dependiendo del caso de uso, también puede ser necesario crear un índice único y / o una restricción de clave externa en la columna proveedor para la tabla de cuentas. En este caso, la definición de columna podría tener este aspecto:

[source, ruby]
-------------------------------------------------------
create_table :accounts do |t|
  t.belongs_to :supplier, index: { unique: true }, foreign_key: true
  # ...
end
-------------------------------------------------------

=2.3 La asociación has_many
Una asociación has_many indica una conexión uno-a-muchos con otro modelo. A menudo encontrará esta asociación en el ""otro lado"" de una asociación belongs_to. Esta asociación indica que cada instancia del modelo tiene cero o más instancias de otro modelo. Por ejemplo, en una aplicación que contiene autores y libros, el modelo de autor podría ser declarado así:

class Author < ApplicationRecord
  has_many :books
end

El nombre del otro modelo se pluraliza cuando se declara una asociación has_many.

La migración correspondiente podría tener este aspecto:

[source, ruby]
-------------------------------------------------------
class CreateAuthors < ActiveRecord::Migration[5.0]
  def change
    create_table :authors do |t|
      t.string :name
      t.timestamps
    end

    create_table :books do |t|
      t.belongs_to :author, index: true
      t.datetime :published_at
      t.timestamps
    end
  end
end
-------------------------------------------------------

=2.4 La asociacion has_many :through
La asociacion has_many :through se utiliza a menudo para establecer una conexión muchos-a-muchos con otro modelo. Esta asociación indica que el modelo de declaración puede coincidir con cero o más instancias de otro modelo, procediendo a través de un tercer modelo. Por ejemplo, considere una práctica médica donde los pacientes hacen citas para ver a los médicos. Las declaraciones de asociación pertinentes podrían tener este aspecto:

[source, ruby]
-------------------------------------------------------
class Physician < ApplicationRecord
  has_many :appointments
  has_many :patients, through: :appointments
end

class Appointment < ApplicationRecord
  belongs_to :physician
  belongs_to :patient
end

class Patient < ApplicationRecord
  has_many :appointments
  has_many :physicians, through: :appointments
end
-------------------------------------------------------

La migración correspondiente podría tener este aspecto:"

[source, ruby]
-------------------------------------------------------
class CreateAppointments < ActiveRecord::Migration[5.0]
  def change
    create_table :physicians do |t|
      t.string :name
      t.timestamps
    end

    create_table :patients do |t|
      t.string :name
      t.timestamps
    end

    create_table :appointments do |t|
      t.belongs_to :physician, index: true
      t.belongs_to :patient, index: true
      t.datetime :appointment_date
      t.timestamps
    end
  end
end
-------------------------------------------------------

La colección de modelos de unión (join) se puede gestionar a través de los métodos de asociación has_many. Por ejemplo, si asigna:

[source, ruby]
-------------------------------------------------------
physician.patients = patients
-------------------------------------------------------

A continuación, los nuevos modelos "Join" se crean automáticamente para los objetos recién asociados. Si algunas de las que ya existían anteriormente faltan, sus filas "Join" se eliminan automáticamente.

La eliminación automática de los modelos de combinación es directa, no destruye los callbacks disparados

La asociación has_many :through también es útil para configurar "accesos directos - shortcuts" a través de asociaciones anidadas (nested) has_many. Por ejemplo, si un documento tiene muchas secciones y una sección tiene muchos párrafos, a veces puede que desee obtener una colección simple de todos los párrafos del documento. Usted podría configurarlo de esta manera:

[source, ruby]
-------------------------------------------------------
class Document < ApplicationRecord
  has_many :sections
  has_many :paragraphs, through: :sections
end

class Section < ApplicationRecord
  belongs_to :document
  has_many :paragraphs
end

class Paragraph < ApplicationRecord
  belongs_to :section
end
-------------------------------------------------------

Con through: especificando :sections, Rails ahora entenderá:

[source, ruby]
-------------------------------------------------------
@document.paragraphs
-------------------------------------------------------

==2.5 La asociación has_one :through
Una asociación has_one :through crea una conexión uno a uno con otro modelo. Esta asociación indica que el modelo de declaración puede coincidir con una instancia de otro modelo procediendo a través de un tercer modelo. Por ejemplo, si cada proveedor tiene una cuenta y cada cuenta está asociada con un historial de cuenta, el modelo de proveedor podría tener este aspecto:

[source, ruby]
-------------------------------------------------------
class Supplier < ApplicationRecord
  has_one :account
  has_one :account_history, through: :account
end

class Account < ApplicationRecord
  belongs_to :supplier
  has_one :account_history
end

class AccountHistory < ApplicationRecord
  belongs_to :account
end
-------------------------------------------------------

La migración correspondiente podría tener este aspecto:

[source, ruby]
-------------------------------------------------------
class CreateAccountHistories < ActiveRecord::Migration[5.0]
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps
    end

    create_table :accounts do |t|
      t.belongs_to :supplier, index: true
      t.string :account_number
      t.timestamps
    end

    create_table :account_histories do |t|
      t.belongs_to :account, index: true
      t.integer :credit_rating
      t.timestamps
    end
  end
end
-------------------------------------------------------

==2.6 La asociación has_and_belongs_to_many
Una asociación has_and_belongs_to_many crea una conexión directa many-to-many con otro modelo, sin modelo intermedio. Por ejemplo, si su aplicación incluye ensamblajes y partes, con cada ensamblaje teniendo muchas partes y cada parte apareciendo en muchos ensamblajes, podría declarar los modelos de esta manera:

[source, ruby]
-------------------------------------------------------
class Assembly < ApplicationRecord
  has_and_belongs_to_many :parts
end

class Part < ApplicationRecord
  has_and_belongs_to_many :assemblies
end
-------------------------------------------------------

La migración correspondiente podría tener este aspecto:

[source, ruby]
-------------------------------------------------------
class CreateAssembliesAndParts < ActiveRecord::Migration[5.0]
  def change
    create_table :assemblies do |t|
      t.string :name
      t.timestamps
    end
    create_table :parts do |t|
      t.string :part_number
      t.timestamps
    end

    create_table :assemblies_parts, id: false do |t|
      t.belongs_to :assembly, index: true
      t.belongs_to :part, index: true
    end
  end
end
-------------------------------------------------------

==2.7 Elegir entre belongs_to y has_one
Si desea establecer una relación de uno a uno entre dos modelos, deberá agregar belongs_to a uno y has_one al otro. ¿Cómo sabes cuál es cuál?

La distinción está en donde se coloca la clave foránea (va en la tabla para la clase que declara la asociación belongs_to), pero debe reflexionar también sobre el significado real de los datos. La relación has_one dice que uno de algo es tuyo, es decir, que algo te indica algo. Por ejemplo, tiene más sentido decir que un proveedor posee una cuenta que una cuenta posee un proveedor. Esto sugiere que las relaciones correctas son así:

[source, ruby]
-------------------------------------------------------
class Supplier < ApplicationRecord
  has_one :account
end

class Account < ApplicationRecord
  belongs_to :supplier
end
-------------------------------------------------------

La migración correspondiente podría tener este aspecto:

[source, ruby]
-------------------------------------------------------
class CreateSuppliers < ActiveRecord::Migration[5.0]
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps
    end
    create_table :accounts do |t|
      t.integer :supplier_id
      t.string  :account_number
      t.timestamps
    end

    add_index :accounts, :supplier_id
  end
end
-------------------------------------------------------

El uso de t.integer :supplier_id hace que el nombre de clave externa sea obvio y explícito. En las versiones actuales de Rails, puede abstraer este detalle de implementación utilizando t.references :supplier.

==2.8 Elegir entre has_many: through y has_and_belongs_to_many
Rails ofrece dos formas diferentes de declarar una relación de muchos a muchos entre modelos. La forma más sencilla es usar has_and_belongs_to_many, lo que le permite hacer la asociación directamente:

[source, ruby]
-------------------------------------------------------
class Assembly < ApplicationRecord
  has_and_belongs_to_many :parts
end

class Part < ApplicationRecord
  has_and_belongs_to_many :assemblies
end
-------------------------------------------------------

La segunda forma de declarar una relación muchos-a-muchos es usar has_many :through. Esto hace la asociación indirectamente, a través de un modelo de unión:

[source, ruby]
-------------------------------------------------------
class Assembly < ApplicationRecord
  has_many :manifests
  has_many :parts, through: :manifests
end

class Manifest < ApplicationRecord
  belongs_to :assembly
  belongs_to :part
end
class Part < ApplicationRecord
  has_many :manifests
  has_many :assemblies, through: :manifests
end
-------------------------------------------------------

La regla más sencilla es que debe establecer una relación has_many :through si necesita trabajar con el modelo de relación como una entidad independiente. Si no necesita hacer nada con el modelo de relación, puede ser más sencillo configurar una relación has_and_belongs_to_many (aunque deberá recordar crear la "join table" en la base de datos).

Debe utilizar has_many: :through si necesita validaciones, callbacks o atributos adicionales en el modelo de union.

==2.9 Asociaciones polimórficas
Un giro un poco más avanzado en las asociaciones es la asociación polimórfica. Con asociaciones polimórficas, un modelo puede pertenecer a más de un modelo, en una sola asociación. Por ejemplo, es posible que tenga un modelo ""imagen"" que pertenezca a un modelo de empleado o un modelo de producto. He aquí cómo se podría declarar esto:

[source, ruby]
-------------------------------------------------------
class Picture < ApplicationRecord
  belongs_to :imageable, polymorphic: true
end

class Employee < ApplicationRecord
  has_many :pictures, as: :imageable
end

class Product < ApplicationRecord
  has_many :pictures, as: :imageable
end
-------------------------------------------------------

Puede pensar en una declaración polimórfica de belongs_to como configurar una interfaz que cualquier otro modelo puede usar. Desde una instancia del modelo Employee, puede recuperar una colección de imágenes: @employee.pictures.

Del mismo modo, puede recuperar @product.pictures.

Si tiene una instancia del modelo de imagen, puede llegar a su padre a través de @picture.imageable. Para que esto funcione, debe declarar tanto una columna de clave foranea como una columna ""type"" en el modelo que declare la interfaz polimórfica:

[source, ruby]
-------------------------------------------------------
class CreatePictures < ActiveRecord::Migration[5.0]
  def change
    create_table :pictures do |t|
      t.string  :name
      t.integer :imageable_id
      t.string  :imageable_type
      t.timestamps
    end

    add_index :pictures, [:imageable_type, :imageable_id]
  end
end
-------------------------------------------------------

Esta migración puede simplificarse mediante el uso de la forma t.references:

[source, ruby]
-------------------------------------------------------
class CreatePictures < ActiveRecord::Migration[5.0]
  def change
    create_table :pictures do |t|
      t.string :name
      t.references :imageable, polymorphic: true, index: true
      t.timestamps
    end
  end
end
-------------------------------------------------------

==2.10 Self Joins
En el diseño de un modelo de datos, a veces se encuentra un modelo que debe tener una relación con sí mismo. Por ejemplo, es posible que desee almacenar todos los empleados en un único modelo de base de datos, pero pueda rastrear las relaciones, como por ejemplo entre el administrador y los subordinados. Esta situación puede ser modelada con asociaciones Self Joins:

[source, ruby]
-------------------------------------------------------
class Employee < ApplicationRecord
  has_many :subordinates, class_name: ""Employee"",
                          foreign_key: ""manager_id""

  belongs_to :manager, class_name: ""Employee""
end
-------------------------------------------------------

Con esta configuración, puede recuperar @employee.subordinates y @employee.manager.

En sus migraciones / esquema, agregará una columna de referencias al propio modelo.

[source, ruby]
-------------------------------------------------------
class CreateEmployees < ActiveRecord::Migration[5.0]
  def change
    create_table :employees do |t|
      t.references :manager, index: true
      t.timestamps
    end
  end
end
-------------------------------------------------------

===3 consejos, trucos y advertencias
Estas son algunas de las cosas que debe saber para hacer un uso eficiente de las asociaciones Active Record en sus aplicaciones de Rails:

Control del almacenamiento en caché
Evitar colisiones de nombres
Actualización del esquema
Controlar el alcance de la asociación
Asociaciones bidireccionales

==3.1 Control del almacenamiento en caché
Todos los métodos de asociación se construyen alrededor del almacenamiento en caché, lo que mantiene el resultado de la consulta más reciente disponible para operaciones adicionales. La caché se comparte incluso entre los métodos. Por ejemplo:

[source, ruby]
-------------------------------------------------------
author.books                 # recupera los libros de la base de datos
author.books.size            # utiliza la copia en caché de libros
author.books.empty?          # utiliza la copia en caché de libros
-------------------------------------------------------

Pero ¿qué pasa si desea volver a cargar la caché, porque los datos podrían haber sido cambiados por alguna otra parte de la aplicación? Simplemente llame a ""reload"" en la asociación:

[source, ruby]
-------------------------------------------------------
author.books                 # recupera los libros de la base de datos
author.books.size            # utiliza la copia en caché de libros
author.books.reload.empty?   # Descarta la copia en caché de libros
                              # Y vuelve a la base de datos
-------------------------------------------------------

==3.2 Evitar las colisiones de nombres
No eres libre de usar cualquier nombre para tus asociaciones. Debido a que crear una asociación agrega un método con ese nombre al modelo, es una mala idea darle a una asociación un nombre que ya está utilizado para un método de instancia de ActiveRecord::Base. El método de asociación invalidaría el método base y rompería las cosas. Por ejemplo, attributes o connection son mal nombres para las asociaciones.

==3.3 Actualización del esquema
Las asociaciones son extremadamente útiles, pero no son mágicas. Usted es responsable de mantener el esquema de la base de datos para que coincida con sus asociaciones. En la práctica, esto significa dos cosas, dependiendo del tipo de asociaciones que está creando. Para asociaciones belongs_to es necesario crear claves foráneas y para asociaciones has_and_belongs_to_many es necesario crear la tabla de unión (join table) adecuada.

3.3.1 Creación de claves foráneas para las asociaciones belongs_to

Cuando declara una asociación belongs_to, debe crear claves foráneas según corresponda. Por ejemplo, considere este modelo:

[source, ruby]
-------------------------------------------------------
class Book < ApplicationRecord
  belongs_to :author
end
-------------------------------------------------------

Esta declaración debe ser respaldada por la declaración de clave foránea adecuada en la tabla de libros:

[source, ruby]
-------------------------------------------------------
class CreateBooks < ActiveRecord::Migration[5.0]
  def change
    create_table :books do |t|
      t.datetime :published_at
      t.string   :book_number
      t.integer  :author_id
    end
  end
end
-------------------------------------------------------

Si crea una asociación algún tiempo después de crear el modelo subyacente, debe recordar crear una migración add_column para proporcionar la clave foránea necesaria.

Es una buena práctica agregar un índice en la clave foránea para mejorar el rendimiento de las consultas y una restricción de clave foránea para garantizar la integridad de los datos referenciales:

[source, ruby]
-------------------------------------------------------
class CreateBooks < ActiveRecord::Migration[5.0]
  def change
    create_table :books do |t|
      t.datetime :published_at
      t.string   :book_number
      t.integer  :author_id
    end

    add_index :books, :author_id
    add_foreign_key :books, :authors
  end
end
-------------------------------------------------------

3.3.2 Creación de tablas de unión (join tables) para las asociaciones has_and_belongs_to_many

Si crea una asociación has_and_belongs_to_many, debe crear explícitamente la tabla de unión. A menos que el nombre de la tabla de unión se especifique explícitamente utilizando la opción: join_table, Active Record crea el nombre utilizando el léxico de los nombres de clase. Por lo tanto, una combinación entre los modelos autor y libros dará el nombre de tabla de unión predeterminada de "authors_books" porque "a" supera a "b" en el orden alfabético.

La precedencia entre los nombres de modelo se calcula utilizando el operador <=> para String. Esto significa que si las cadenas son de diferentes longitudes y las cadenas son iguales en comparación con la longitud más corta, entonces la cadena más larga se considera de mayor precedencia léxica que la más corta. Por ejemplo, se podría esperar que las tablas "paper_boxes" y "papers" generen un nombre de tabla de unión de "papers_paper_boxes" debido a la longitud del nombre "paper_boxes", pero de hecho genera un nombre de tabla de unión de "paper_boxes_papers" ( Porque el subrayado '_' es lexicográficamente menor que 's' en codificaciones comunes).

Independientemente del nombre, debe generar manualmente la tabla de unión con una migración adecuada. Por ejemplo, considere estas asociaciones:

[source, ruby]
-------------------------------------------------------
class Assembly < ApplicationRecord
  has_and_belongs_to_many :parts
end

class Part < ApplicationRecord
  has_and_belongs_to_many :assemblies
end
-------------------------------------------------------

Estos deben ser respaldados por una migración para crear la tabla assemblies_parts. Esta tabla debe crearse sin una clave primaria:

[source, ruby]
-------------------------------------------------------
class CreateAssembliesPartsJoinTable < ActiveRecord::Migration[5.0]
  def change
    create_table :assemblies_parts, id: false do |t|
      t.integer :assembly_id
      t.integer :part_id
    end

    add_index :assemblies_parts, :assembly_id
    add_index :assemblies_parts, :part_id
  end
end
-------------------------------------------------------

Pasamos id :false a create_table porque esa tabla no representa un modelo. Eso es necesario para que la asociación funcione correctamente. Si observas cualquier comportamiento extraño en una asociación has_and_belongs_to_many como ID de modelo mutilado, o excepciones sobre IDs en conflicto, es probable que te hayas olvidado de ese detalle.

También puede utilizar el método create_join_table

[source, ruby]
-------------------------------------------------------
class CreateAssembliesPartsJoinTable < ActiveRecord::Migration[5.0]
  def change
    create_join_table :assemblies, :parts do |t|
      t.index :assembly_id
      t.index :part_id
    end
  end
end
-------------------------------------------------------

=3.4 Control del alcance de la asociación
De forma predeterminada, las asociaciones buscan objetos sólo dentro del ámbito del módulo actual. Esto puede ser importante cuando declara los modelos Active Record dentro de un módulo. Por ejemplo:

[source, ruby]
-------------------------------------------------------
module MyApplication
  module Business
    class Supplier < ApplicationRecord
       has_one :account
    end

    class Account < ApplicationRecord
       belongs_to :supplier
    end
  end
end
-------------------------------------------------------

Esto funcionará bien, ya que tanto la clase proveedor como la clase cuenta se definen dentro del mismo ámbito. Pero lo siguiente no funcionará, ya que el proveedor y la cuenta se definen en ámbitos diferentes:

[source, ruby]
-------------------------------------------------------
module MyApplication
  module Business
    class Supplier < ApplicationRecord
       has_one :account
    end
  end
  module Billing
    class Account < ApplicationRecord
       belongs_to :supplier
    end
  end
end
-------------------------------------------------------

Para asociar un modelo con un modelo en un namespace diferente, debe especificar el nombre completo de la clase en la declaración de asociación:

[source, ruby]
-------------------------------------------------------
module MyApplication
  module Business
    class Supplier < ApplicationRecord
       has_one :account,
        class_name: "MyApplication::Billing::Account"
    end
  end

  module Billing
    class Account < ApplicationRecord
       belongs_to :supplier,
        class_name: "MyApplication::Business::Supplier"
    end
  end
end
-------------------------------------------------------

==3.5 Asociaciones bidireccionales
Es normal que las asociaciones trabajen en dos direcciones, requiriendo la declaración en dos modelos diferentes:

[source, ruby]
-------------------------------------------------------
class Author < ApplicationRecord
  has_many :books
end

class Book < ApplicationRecord
  belongs_to :author
end
-------------------------------------------------------

Active Record intentará identificar automáticamente que estos dos modelos comparten una asociación bidireccional basada en el nombre de la asociación. De esta manera, Active Record sólo cargará una copia del objeto Author, haciendo que su aplicación sea más eficiente y evite datos incoherentes:

[source, ruby]
-------------------------------------------------------
a = Author.first
b = a.books.first
a.first_name == b.author.first_name # => true
a.first_name = 'David'
a.first_name == b.author.first_name # => true
-------------------------------------------------------

Active Record admite la identificación automática para la mayoría de las asociaciones con nombres estándar. Sin embargo, Active Record no identificará automáticamente asociaciones bidireccionales que contengan cualquiera de las siguientes opciones:

:conditions
:through
:polymorphic
:class_name
:foreign_key

Por ejemplo, considere las siguientes declaraciones de modelo:

[source, ruby]
-------------------------------------------------------
class Author < ApplicationRecord
  has_many :books
end

class Book < ApplicationRecord
  belongs_to :writer, class_name: 'Author', foreign_key: 'author_id'
end
-------------------------------------------------------

Active Record ya no reconocerá automáticamente la asociación bidireccional:

[source, ruby]
-------------------------------------------------------
a = Author.first
b = a.books.first
a.first_name == b.writer.first_name # => true
a.first_name = 'David'
a.first_name == b.writer.first_name # => false
-------------------------------------------------------

Active Record proporciona la opción: inverse_of para que pueda declarar explícitamente asociaciones bidireccionales:

[source, ruby]
-------------------------------------------------------
class Author < ApplicationRecord
  has_many :books, inverse_of: 'writer'
end

class Book < ApplicationRecord
  belongs_to :writer, class_name: 'Author', foreign_key: 'author_id'
end
-------------------------------------------------------

Al incluir la opción: inverse_of en la declaración de asociación has_many, Active Record reconocerá ahora la asociación bidireccional:

[source, ruby]
-------------------------------------------------------
a = Author.first
b = a.books.first
a.first_name == b.writer.first_name # => true
a.first_name = 'David'
a.first_name == b.writer.first_name # => true
-------------------------------------------------------

Existen algunas limitaciones con  :inverse_of

No trabajan con asociaciones :through.
No funcionan con asociaciones polimórficas.
No trabajan con asociaciones :as
